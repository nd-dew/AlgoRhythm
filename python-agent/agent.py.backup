# agent_server.py
import os
import asyncio
from fastapi import FastAPI
from google.adk.agents.llm_agent import LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai.types import Content, Part

# Configure Vertex AI via environment variables
os.environ['GOOGLE_CLOUD_PROJECT'] = 'qwiklabs-gcp-00-acb9fdb9ec26'
os.environ['GOOGLE_CLOUD_LOCATION'] = 'us-central1'
os.environ['GOOGLE_GENAI_USE_VERTEXAI'] = 'true'

# Define your agent following ADK documentation
strudel_agent = LlmAgent(
    model='gemini-2.0-flash',
    name='strudel_music_agent',
    description='A helpful agent that generates Strudel music code.',
    instruction='''You are an expert at generating Strudel (TidalCycles) music code.
When a user asks you to create or modify music:
1. Generate valid Strudel JavaScript code
2. Return ONLY the code, without explanations or markdown code blocks
3. Make sure the code is syntactically correct and ready to run
''',
)

# Setup session service
session_service = InMemorySessionService()

app = FastAPI()

# We'll create the runner per request to avoid async cleanup issues
def get_runner():
    return Runner(
        agent=strudel_agent,
        app_name='strudel_app',
        session_service=session_service
    )

@app.post("/run")
async def run_agent(payload: dict):
    """
    Endpoint to run the ADK agent
    Expects: { "input": "user prompt here" }
    Returns: { "result": "agent response" }
    """
    runner = None
    try:
        user_input = payload.get("input", "")
        if not user_input:
            return {"error": "No input provided", "result": None}
        
        # Use a consistent user and session ID
        user_id = "strudel_user"
        session_id = f"session_{hash(user_input) % 10000}"  # Simple session per unique prompt
        
        # Create or get session
        try:
            await session_service.create_session(
                app_name='strudel_app',
                user_id=user_id,
                session_id=session_id
            )
        except Exception:
            # Session might already exist, that's okay
            pass
        
        # Create runner for this request
        runner = get_runner()
        
        # Create content for the agent (as per ADK docs)
        user_content = Content(parts=[Part(text=user_input)])
        
        # Run the agent and collect events (using Runner.run_async from docs)
        events = []
        async for event in runner.run_async(
            user_id=user_id,
            session_id=session_id,
            new_message=user_content
        ):
            events.append(event)
        
        # Extract the final response from events
        result = ""
        for event in events:
            if event.is_final_response and event.content:
                # Get the text from the content
                if event.content.parts:
                    for part in event.content.parts:
                        if part.text:
                            result += part.text
        
        if not result:
            result = "No response generated"
        
        return {"result": result}
        
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error in run_agent: {error_details}")
        return {"error": str(e), "result": None, "details": error_details}
    finally:
        # Suppress cleanup errors by not explicitly closing
        pass

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT", "8000")))
